=========================================================== C MEMORY ADDRESS

==========Memory Address

When a variable is created in C, a memory address in assigned to the variable.

The memory address is the location of where the variable is stored on the computer.

When we assign a value to the variable, it is stored in this memory adress.

To access it, use the reference operator (&), and the result represents where the variable is stored:

-----

int myAge = 43;
printf("%p", &myAge);  // Outputs 0x7ffe5367e044

-----

***NOTE: The memory address is in hexadecimal form (0x...). You will probably not get the same result in your program, as this depends on where the variable is stored on your computer.

You should also note that &myAge is often called a "pointer". A pointer basically stores the memory address of a variable as its values. To print pointer values, we use te %p format specifier.

You will learn much more about pointers in the next chapter.

=================================================================
|								|
| Why is it useful to know the memory address?			|
|								|
| Pointers are important in C, because they allow us to 	|
| manipulate the data in the computer's memory - this can	|
| reduce the code and improve the performance.			|
|								|
| Pointers are one of the things that make C stand out		|
| from other programming languages, like Python and Java.	|
|								|
================================================================= 


=========================================================== C POINTERS


==========Creating Pointers

We learned from the previous chapter, that we can get the memory address of a variable with the reference operator &:

-----

int myAge = 43; // an int variable

printf("%d", myAge);  // Outputs the value of myAge (43)
printf("%p", &myAge);  // Outputs the memory address of myAge (0x7ffe5367e044)

-----

A pointer is a variable that stores the memory address of another variable as its value.

A pointer variable points to a data type (like int) of the same type, and is created with the * operator.

The address of the variable you are working is assigned to the pointer:

-----

int myAge = 43;		// An int variable
int* ptr = &myAge;	// A pointer variable, with the name ptr, that stores the address of myAge

// Output the value of myAge (43)
printf("%d\n", myAge);

// Output the memory address of myAge (0x7ffe5367e044)
printf("%p\n", &myAge);

// Output the memory address of myAge with the pointer
printf("%p\m", ptr);

-----

Explanation:

Create a pointer variable with the name ptr, that points to an int variable (myAge). Note that the type of the pointer has to match the type of the variable you're working with (int in our exmaple).

Use the & operator to store the memory address of the myAge variable, and assign it to the pointer.

Now, ptr holds the value of myAge's memory address.



==========Deference

In the example above, we used the pointer variable to get the memory address of a variable (used together with the & reference operator).

You can also get the value of the variable the pointer points to, by using * operator (the deference operator):

-----

int myAge = 43;		// Variable declaration
int* ptr = &myAge;	// Pointer declaration

// Reference: Output the memory address of myAge with the pointer (0x7ffe5367e044)
printf("%p\n", ptr);

// Deference: Output the memory address of myAge with the pointer (43)
printf("%d\n", *ptr);

-----

***NOTE: The * sign can be confusing here, as it does two different things in our code:

	* When used in declaration (int* ptr), it creates a pointer variable.

	* When not used in declaration, it act as a deference operator.



Good To Know: There are two ways to declare pointer variables in C:

-----

int* myNum;
int *myNum;

-----

***NOTES ON POINTERS:

Pointers are one of the things that make C stand out from other programming languages, like Python and Java.


They are important C, because they allow us to manipulate the data in the computer's memory. This can reduce the code and improve the performance. If you are familiar with data structures like lists, trees and graphs, you should know that pointers are especially useful for implementing those. And sometimes you even have to use pointers, for example when working with files and memory management.

But be careful; pointers must be handled with care, since it is possible to damage data stored in other memory address.



=========================================================== C POINTERS AND ARRAYS

=====Pointers & Arrays

You can also use pointers to access arrays.

Consider the following array of integers:

-----

int myNumbers[4] = {25, 50, 75, 100};

-----


We learned from the arrays chapter that we can loop through the array elements with a for loop:

-----

int myNumbers[4] = {25, 50, 75, 100};
int i;

for (i = 0; i < 4; i++) {
  printf("%d\n", myNumbers[i]);
}

Result:

25
50
75
100

-----

Now, instead of printing the value of each array element, let's print the memory address of each array element:

-----

int myNumber[4] = {25, 50, 75, 100};
int i;

for (i = 0; i < 4; i++) {
  printf("%p\n", &myNumbers[i]);
}

Result:

0x7ffe70f9d8f0
0x7ffe70f9d8f4
0x7ffe70f9d8f8
0x7ffe70f9d8fc

-----


Note that the last number of each of the element's memory address is different, with and addition of 4.

It is because the size of an int type is typically 4 bytes, remember:

-----

// Create an int variable
int myInt;

// Get the memory size of an int
printf("%lu", sizeof(myInt));

Result:

4

-----



So from the "memory address example" above, you can see that compilet reserves 4 bytes of memory for each array element, which mean that the entire array  takes up 16 bytes (4 * 4) of memory storage:

-----

int myNumbers[4] = {25, 50, 75, 100};

// Get the size of the myNumbers array
printf("%lu", sizeof(myNumbers));

Result:

16

-----


==========How Are Pointers Related to Arrays


Ok, so what's the relationship between pointers and arrays? Well, in C, the name of an array, is actually a pointer to the first element of the array.

Confused? Let's try to understand this better, and use our "memory address example" above again.

The memory address of the first element is the same as the name of the array:

-----

int myNumber[4] = {25, 50, 75, 100};

// Get the memory address of the myNumbers array
printf("%p\n", myNumbers);

// Get the memory address of the first array element
printf("%p\n", &myNumbers[0]);

Result:

0x7ffe70f9d8f0
0x7ffe70f9d8f0

-----


This basically means that we can work with arrays through pointers!

How? Since myNumbers is a pointer to the first element in myNumber, you can also use the * operator to access it:

-----

int myNumber[4] = {25, 50, 70, 100};

// Get the value of the first element in myNumbers
printf("%d", *myNumbers);

Result:

25

-----

To access the rest of the elements in myNumbers, you can increment the pointer/array (+1, +2, etc):

-----

int myNumbers[4] = {25, 50, 75, 100};

// Get the value of the second element in myNumbers
printf("%d\n", *(myNumbers + 1));

// Get the value of the third element in myNumbers
printf("%d", *(myNumbers + 2));

// and so on...

Result:

50

70

-----


Or loop through it:


-----

int myNumbers[4] = {25, 50, 75, 100};
int *ptr = myNumbers;
int i;

for (i = 0; i < 4; i++) {
  printf("%d\n", *(ptr + i));
}

Result:

25
50
75
100

-----


It is also possible to change the value of array elements with pointers:


-----

int myNumbers[4] = {25, 50, 75, 100};

// Change the value of the first element to 13
*myNumbers = 13;

// Change the value of the second element to 17
*(myNumbers +1) = 17;

// Get the value of the first element
printf("%d\n", *myNumbers);

// Get the value of the second element
printf("%d\n", *(myNumbers + 1));

Result:

13
17

-----


This way of working with arrays might seem a bit excessive. Especially with simple arrays like in the examples above. However, for large arrays, it can be much more efficient to access and manipulate arrays with pointers.

It is also considered faster and easier to access two-dimensional arrays with pointers.

And since strings are actually arrays, you can also use pointers to access strings.

For now, it's great taht you know how this works. But like we specified in the previous chapter; pointers must be handled with care, since it is possible to overwrite other data stored in memory.
